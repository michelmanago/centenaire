// libs
import {useRouter} from 'next/router';
import { useState } from 'react';

// utils
import cleanForSlug from '../../utils/cleanForSlug';
import getAvailableSlug from '../../utils/getAvailableSlug';
import { pageFormat, blockFormat} from '../../utils/page-editor-formats';

// components
import InputSlug from './inputs/InputSlug';
import InputAddBlock from './inputs/InputAddBlock';
import PageEditorSidebar from './sidebar/page-editor-sidebar';
import BlockContentEditor from './blocks/BlockContentEditor';


// helpers
const getSlugWithoutLocale = (slugsWithLocale, langue) => slugsWithLocale.replace(langue + "/", "")
const pagesWithSlugsWithoutLocale = pages => pages.map(page => ({...page, pageSlug: getSlugWithoutLocale(page.pageSlug, page.language)}))

// create the editable slug with no locale
const pagesWithSlugsWithoutLocales = pages => pages.map(page => ({...page, slugWithoutLocale: page.pageSlug.replace(page.language + "/", "")}))

const isTitleEmpty = title => (!title || !title.replace(/\s/g, '').length)

export default function PageEditor({onFormSubmitted, editedPages}) {

    // hooks
    const { locales } = useRouter();

    // States
    // form
    const [pages, setPages] = useState(editedPages ? pagesWithSlugsWithoutLocales(editedPages) : locales.map(_locale => pageFormat(_locale)))
    const [currentPageIndex, setCurrentPageIndex] = useState(0)
    const [isSubmitting, setIsSubmitting] = useState(false)

    // utils
    
    const notAllowedToSave = () => {

        // one translations empty
        let allTitlesAreEmpty = pages.every(page => isTitleEmpty(page.pageName))

        return allTitlesAreEmpty ? true : false
    }

    const isEditing = !!editedPages;
    const currentPage = pages[currentPageIndex]
    const updateCurrentPage = (values) => {
        
        if(pages && pages.length){
            
            setPages(pages.map((page, pageIndex) => {

                if(pageIndex === currentPageIndex){
                    return {
                        ...currentPage,
                        ...values
                    }
                } else {
                    return page
                }
    
            }))
        }
        
    }

    const generateEmptyTitles = form => {

        let output = []

        const pagesWithNoTitle = form.filter(page => isTitleEmpty(page.pageName))

        if(pagesWithNoTitle.length === pages.length){

            const title = "Brouillon"

            output = form.map(page => ({
                ...page,
                pageName: title,
                pageSlug: page.language + "/" + cleanForSlug(title),
            }))
        }
        else if(pagesWithNoTitle.length){

            const firstPageWithTitle = form.find(page => !isTitleEmpty(page.pageName))
            const firstPageWithTitleId = firstPageWithTitle.id || firstPageWithTitle.temp_id

            output = form.map(page => {

                // when creating page there is no page.id
                const id = page.id || page.temp_id

                if(id === firstPageWithTitleId){
                    return firstPageWithTitle
                } 
                
                else if (isTitleEmpty(page.pageName)){
                    return ({
                        ...page,
                        pageName: firstPageWithTitle.pageName,
                        pageSlug: page.language + "/" + cleanForSlug(firstPageWithTitle.slugWithoutLocale),
                    })
                }

                else {
                    return page
                }

            })

        } else {
            output = form
        }

        return output        
    }

    const checkSlugsAtTheEnd = async form => {
    
        const output = [...form]

        // slugs that might be generated by title and that already exists in database
        const mightBeDirtySlugs = []

        form.forEach((page, pageIndex) => {
            
            if(!isEditing || editedPages[pageIndex].pageSlug !== page.pageSlug){
                mightBeDirtySlugs.push({
                    index: pageIndex,
                    slug: page.pageSlug
                })
            }

        })

        // check 

        const promises = mightBeDirtySlugs.map(slugItem => getAvailableSlug(slugItem.slug).then(checkedSlug => {

            return ({index: slugItem.index, slug: checkedSlug})

        }))

        const checkedSlugs = await Promise.all(promises)

        checkedSlugs.forEach(slugItem => {

            output[slugItem.index].pageSlug = slugItem.slug

        })


        return output
        
    } 

    // methods

    const onSubmitPage = async () => {


        let form = [...pages]

        // setIsSubmitting(true)

        // generate empty titles
        form = generateEmptyTitles(form)

        // check slugs
        form = await checkSlugsAtTheEnd(form)

        // send pages to form
        try{
            await onFormSubmitted(form);
        } catch (err){
            console.log(err)
        } finally {
            setIsSubmitting(false)   
        }
    };

    // others
    const languagesLists = locales.map(_locale => ({title: _locale.toUpperCase(), value: _locale}));


    // setters
    const setSlug = value => updateCurrentPage({pageSlug: currentPage.language + "/" + value, slugWithoutLocale: value})
    const setTitle = e => {
        
        const cleanedSlug = cleanForSlug(e.target.value)
        updateCurrentPage({pageName: e.target.value, pageSlug: currentPage.language + "/" + cleanedSlug, slugWithoutLocale: cleanedSlug})

    }
    const addBlockContent = type => {

        // if blocks are draggable we must count each items's postions to compute a new position
        const newPosition = currentPage.blocks.length
        const newBlock = blockFormat(editedPages ? currentPage.id : null, currentPage.language, type, newPosition)

        updateCurrentPage({
            blocks: [
                ...currentPage.blocks,
                newBlock
            ]
        })

    };
    const setBlockContent = blockPosition => value => {
        
        let blocks = currentPage.blocks.map(block => {

            if(block.position === blockPosition){
                return {
                    ...block,
                    content: value
                }
            } else {
                return block
            }

        })

        updateCurrentPage({blocks})   
    }

    const removeBlockContent = blockPosition => value => {
        
        let blocks = currentPage.blocks.filter(block => block.position !== blockPosition)

        updateCurrentPage({blocks})   
    }

    // listeners
    const onChangeLanguage = e => setCurrentPageIndex(languagesLists.findIndex(v => v.value === e.target.value))


    return (
        <div className="flex p-8 bg-white border gap-x-8">

            {/* Left */}
            <div className="flex-1 w-2/5">

                {/* Mode de page */}
                <h1 className="mb-5 text-4xl font-bold">
                    {isEditing ? 'Modifier la page' : 'Ajouter une nouvelle page'}
                </h1>

                {/* Input - Title */}
                <input
                    onChange={setTitle}
                    value={currentPage.pageName}
                    className="w-full px-5 py-4 mb-5 border rounded"
                    type="text"
                    placeholder="Titre de la page"
                />

                {/* Input - Slug */}
                {currentPage.pageSlug && (
                    <InputSlug 
                        currentLanguage={currentPage.language} 

                        originalSlug={editedPages ? editedPages[currentPageIndex].pageSlug :Â ""}
                        slug={currentPage.pageSlug} 
                        slugWithoutLocale={currentPage.slugWithoutLocale}

                        setSlug={setSlug} 
                    />
                )}

                {/* Input - add block */}
                <InputAddBlock addBlock={addBlockContent} />

                {/* Content blocks */}
                {currentPage.blocks && (
                    currentPage.blocks.map((block, blockIndex) => (
                        <BlockContentEditor 
                            key={"block-" + block.position} 
                            type={block.type}
                            content={block.content}

                            // actions
                            setContent={setBlockContent(block.position)}
                            removeBlockContent={removeBlockContent(block.position)}
                        />
                    ))
                )}
            </div>

            {/* Right */}
            <PageEditorSidebar
            
                updateState={updateCurrentPage}
                isEditing={isEditing}
            
                language={currentPage.language} languagesLists={languagesLists}
                pageSlug={currentPage.pageSlug}
                author={currentPage.author}
                category={currentPage.page}
                created_at={currentPage.created_at} last_modified={currentPage.last_modified}
                
                onSubmit={onSubmitPage}
                isSubmitting={isSubmitting}

                onChangeLanguage={onChangeLanguage}

                notAllowedToSave={notAllowedToSave()}

            />

        </div>
    );
}

PageEditor.NOT_ALLOWED_TO_SAVE = {

    TRANSLATIONS_EMPTY: "TRANSLATIONS_EMPTY",

}
